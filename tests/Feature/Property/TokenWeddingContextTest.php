<?php

namespace Tests\Feature\Property;

use App\Models\User;
use App\Models\Wedding;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Laravel\Sanctum\Sanctum;
use Tests\TestCase;

/**
 * Feature: wedding-saas-foundation, Property 5: Token com Contexto de Wedding
 * 
 * For any API token generated by the system, the token should be associated
 * with the user_id and the user should have a current_wedding_id defined
 * (except for Admins).
 * 
 * Validates: Requirements 4.2
 */
class TokenWeddingContextTest extends TestCase
{
    use RefreshDatabase;

    /**
     * Property test: Non-admin users with token must have wedding context for protected routes
     * @test
     */
    public function non_admin_users_with_token_require_wedding_context(): void
    {
        $roles = ['couple', 'organizer'];

        for ($i = 0; $i < 100; $i++) {
            $wedding = Wedding::create(['title' => "Wedding {$i}"]);
            $role = $roles[array_rand($roles)];

            // Create user with wedding access and current_wedding_id set
            $user = User::factory()->create([
                'role' => $role,
                'current_wedding_id' => $wedding->id,
            ]);
            $user->weddings()->attach($wedding->id, [
                'role' => $role,
                'permissions' => array_keys(\App\Services\PermissionService::MODULES),
            ]);

            Sanctum::actingAs($user);

            // User with current_wedding_id should be able to access wedding-scoped routes
            $response = $this->getJson('/api/wedding');

            $response->assertStatus(200);
            $response->assertJsonStructure([
                'wedding_id',
                'user',
            ]);
            $response->assertJson([
                'wedding_id' => $wedding->id,
            ]);

            // Cleanup
            $user->weddings()->detach();
            $user->delete();
            $wedding->delete();
        }
    }

    /**
     * Property test: Token is associated with user_id
     * @test
     */
    public function token_is_associated_with_user_id(): void
    {
        for ($i = 0; $i < 100; $i++) {
            $wedding = Wedding::create(['title' => "Wedding {$i}"]);
            $role = fake()->randomElement(['admin', 'couple', 'organizer', 'guest']);

            $user = User::factory()->create([
                'role' => $role,
                'current_wedding_id' => $role !== 'admin' ? $wedding->id : null,
            ]);

            if ($role !== 'admin' && $role !== 'guest') {
                $user->weddings()->attach($wedding->id, [
                    'role' => $role,
                    'permissions' => array_keys(\App\Services\PermissionService::MODULES),
                ]);
            }

            // Create a token for the user
            $token = $user->createToken('test-token');

            // Verify token is associated with the user
            $this->assertEquals($user->id, $token->accessToken->tokenable_id);
            $this->assertEquals(User::class, $token->accessToken->tokenable_type);

            // Cleanup
            $user->tokens()->delete();
            if ($role !== 'admin' && $role !== 'guest') {
                $user->weddings()->detach();
            }
            $user->delete();
            $wedding->delete();
        }
    }

    /**
     * Property test: Admin users can operate without wedding context
     * @test
     */
    public function admin_users_can_operate_without_wedding_context(): void
    {
        for ($i = 0; $i < 100; $i++) {
            $admin = User::factory()->create([
                'role' => 'admin',
                'current_wedding_id' => null,
            ]);

            Sanctum::actingAs($admin);

            // Admin should be able to access user endpoint
            $response = $this->getJson('/api/user');

            $response->assertStatus(200);
            $response->assertJson([
                'id' => $admin->id,
                'role' => 'admin',
            ]);

            // Cleanup
            $admin->delete();
        }
    }

    /**
     * Property test: Wedding context from header takes precedence
     * @test
     */
    public function wedding_context_from_header_takes_precedence(): void
    {
        for ($i = 0; $i < 100; $i++) {
            $wedding1 = Wedding::create(['title' => "Wedding 1 - {$i}"]);
            $wedding2 = Wedding::create(['title' => "Wedding 2 - {$i}"]);

            // Create user with access to both weddings, current_wedding_id = wedding1
            $user = User::factory()->create([
                'role' => 'couple',
                'current_wedding_id' => $wedding1->id,
            ]);
            $user->weddings()->attach($wedding1->id, ['role' => 'couple', 'permissions' => []]);
            $user->weddings()->attach($wedding2->id, ['role' => 'couple', 'permissions' => []]);

            Sanctum::actingAs($user);

            // Request with X-Wedding-ID header pointing to wedding2
            $response = $this->getJson('/api/wedding', [
                'X-Wedding-ID' => $wedding2->id,
            ]);

            $response->assertStatus(200);
            // The wedding context should be wedding2 (from header)
            $response->assertJson([
                'wedding_id' => $wedding2->id,
            ]);

            // Cleanup
            $user->weddings()->detach();
            $user->delete();
            $wedding1->delete();
            $wedding2->delete();
        }
    }

    /**
     * Property test: User's current_wedding_id is used when no header provided
     * @test
     */
    public function users_current_wedding_id_is_used_when_no_header(): void
    {
        for ($i = 0; $i < 100; $i++) {
            $wedding = Wedding::create(['title' => "Wedding {$i}"]);

            $user = User::factory()->create([
                'role' => 'couple',
                'current_wedding_id' => $wedding->id,
            ]);
            $user->weddings()->attach($wedding->id, ['role' => 'couple', 'permissions' => []]);

            Sanctum::actingAs($user);

            // Request without X-Wedding-ID header
            $response = $this->getJson('/api/wedding');

            $response->assertStatus(200);
            $response->assertJson([
                'wedding_id' => $wedding->id,
            ]);

            // Cleanup
            $user->weddings()->detach();
            $user->delete();
            $wedding->delete();
        }
    }

    /**
     * Property test: Guest users with token can access APP module
     * @test
     */
    public function guest_users_with_token_can_access_app_module(): void
    {
        for ($i = 0; $i < 100; $i++) {
            $guest = User::factory()->create([
                'role' => 'guest',
                'current_wedding_id' => null,
            ]);

            Sanctum::actingAs($guest);

            // Guest should be able to access APP module endpoints
            $response = $this->getJson('/api/app/notifications');
            $response->assertStatus(200);

            $response = $this->getJson('/api/app/gamification');
            $response->assertStatus(200);

            // Cleanup
            $guest->delete();
        }
    }

    /**
     * @test
     */
    public function token_abilities_can_be_verified(): void
    {
        $wedding = Wedding::create(['title' => 'Test Wedding']);

        $user = User::factory()->create([
            'role' => 'couple',
            'current_wedding_id' => $wedding->id,
        ]);
        $user->weddings()->attach($wedding->id, ['role' => 'couple', 'permissions' => []]);

        // Create token with specific abilities
        $token = $user->createToken('test-token', ['read', 'write']);

        // Verify token has the specified abilities
        $this->assertTrue($token->accessToken->can('read'));
        $this->assertTrue($token->accessToken->can('write'));
        $this->assertFalse($token->accessToken->can('delete'));

        // Cleanup
        $user->tokens()->delete();
        $user->weddings()->detach();
        $user->delete();
        $wedding->delete();
    }

    /**
     * @test
     */
    public function multiple_tokens_per_user_are_independent(): void
    {
        $wedding = Wedding::create(['title' => 'Test Wedding']);

        $user = User::factory()->create([
            'role' => 'couple',
            'current_wedding_id' => $wedding->id,
        ]);
        $user->weddings()->attach($wedding->id, ['role' => 'couple', 'permissions' => []]);

        // Create multiple tokens
        $token1 = $user->createToken('device-1');
        $token2 = $user->createToken('device-2');

        // Both tokens should be associated with the same user
        $this->assertEquals($user->id, $token1->accessToken->tokenable_id);
        $this->assertEquals($user->id, $token2->accessToken->tokenable_id);

        // Tokens should have different IDs
        $this->assertNotEquals($token1->accessToken->id, $token2->accessToken->id);

        // User should have 2 tokens
        $this->assertEquals(2, $user->tokens()->count());

        // Cleanup
        $user->tokens()->delete();
        $user->weddings()->detach();
        $user->delete();
        $wedding->delete();
    }
}
